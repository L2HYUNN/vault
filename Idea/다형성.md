```js
// 3. each 만들기
  // 1. _each로 _map, _filter 중복 제거

  // 2. 외부 다형성
    // 1. array_like, arguments, document.querySelectorAll
console.log(
  [1, 2, 3, 4].map(function(val) {
    return val * 2;
  })
);

console.log(
  [1, 2, 3, 4].filter(function(val) {
    return val % 2;
  })
);

console.log(document.querySelectorAll('*'));
```

자바스크립트에는 기본적으로 map, filter와 같은 함수가 존재한다.

하지만 이들은 함수가 아닌 메서드이다. 메서드는 순수함수가 아닌 객체의 상태에 따라 결과가 달라지는 특징을 가지고 있기 때문에 우리가 만든 map, filter와는 여러가지 차이가 있다.

메서드는 객체지향 프로그래밍이다. 자바스크립트의 map, filter는 객체의 메서드이다. 메서드의 특징은 해당 클래스에 정의되어 있기 때문에 해당 클래스의 인스턴스에서만 사용할 수 있는 특징이 있다. 

자바스크립트에는 아래와 같은 array_like 객체가 많이 존재한다.

```js
$('div')
```

위와 같은 제이쿼리로 만들어진 객체는 array가 아닌 array-like 객체이다.

```js
document.querySelectorAll('*');
```

제이쿼리의 문법과 비슷한 네이티브 버전의 querySelector 또한 배열이 아닌 array-like 이기 때문에 다음과 같은 코드를 사용할 수 없다.

```js
document.querySelectorAll('*').map(function(node) {
	return node.nodeName;
})
```

이것은 객체지향의 특징이기 때문에 특정 클래스의 인스턴스가 아니면 사용할 수 없는, 형을 다루기 어려운 부분이 있다. 즉, 다형성 지원에 어려운 부분이 있다. 

함수형 프로그래밍은 함수를 먼저 만들고 그에 따라 데이터를 구성하기 때문에 다형성을 만족하는 유연하고 실용적인 프로그래밍을 할 수 있게 된다. 

아래의 코드는 실제로 동작할 수 있다.

> 우리가 만든 코드는  array-like 객체에도 동작한다.

```js
console.log(
	_map(document.querySelectorAll('*'), function(node) {
		return node.nodeName;
	})
);
```

> document.querySelectorAll의 결과를 살펴보면 `__proto__`는 `Array`가 아닌 `NodeList`이다.

